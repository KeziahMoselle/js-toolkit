{"version":3,"sources":["../../../../src/abstracts/Base/classes/Options.js"],"names":["deepmerge","noCase","isObject","getAttributeName","name","delimiter","Options","element","schema","String","Number","Boolean","Array","Object","entries","forEach","config","isObjectConfig","types","includes","type","Error","defaultValue","default","defineProperty","get","set","value","enumerable","attributeName","hasAttribute","setAttribute","getAttribute","val","JSON","parse","setTimeout","stringify","constructor","isArray","TypeError","removeAttribute"],"mappings":";;;;;;AAAA,OAAOA,SAAP,MAAsB,WAAtB;AACA,SAASC,MAAT,QAAuB,SAAvB;AACA,OAAOC,QAAP,MAAqB,gCAArB;;AAWA,SAASC,gBAAT,CAA0BC,IAA1B,EAAgC;AAC9B,+BAAsBH,MAAM,CAACG,IAAD,EAAO;AAAEC,IAAAA,SAAS,EAAE;AAAb,GAAP,CAA5B;AACD;;;;;;;;IAKoBC,O;AA4BnB,mBAAYC,OAAZ,EAAqBC,MAArB,EAA6B;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA,aAvBnB;AAuBmB;;AAAA;AAAA;AAAA,aAdZ;AACfC,QAAAA,MAAM,EAAE,EADO;AAEfC,QAAAA,MAAM,EAAE,CAFO;AAGfC,QAAAA,OAAO,EAAE,KAHM;AAIfC,QAAAA,KAAK,EAAE;AAAA,iBAAM,EAAN;AAAA,SAJQ;AAKfC,QAAAA,MAAM,EAAE;AAAA,iBAAO,EAAP;AAAA;AALO;AAcY;;AAC3B,0CAAgBN,OAAhB;;AAEAM,IAAAA,MAAM,CAACC,OAAP,CAAeN,MAAf,EAAuBO,OAAvB,CAA+B,gBAAoB;AAAA;AAAA,UAAlBX,IAAkB;AAAA,UAAZY,MAAY;;AACjD,UAAMC,cAAc,GAAG,CAACX,OAAO,CAACY,KAAR,CAAcC,QAAd,CAAuBH,MAAvB,CAAxB;AAGA,UAAMI,IAAI,GAAGH,cAAc,GAAGD,MAAM,CAACI,IAAV,GAAiBJ,MAA5C;;AAEA,UAAI,CAACV,OAAO,CAACY,KAAR,CAAcC,QAAd,CAAuBC,IAAvB,CAAL,EAAmC;AACjC,cAAM,IAAIC,KAAJ,iBACIjB,IADJ,sGAAN;AAGD;;AAGD,UAAMkB,YAAY,GAAGL,cAAc,GAAGD,MAAM,CAACO,OAAV,GAAoB,sBAAA,KAAI,iBAAJ,CAAoBH,IAAI,CAAChB,IAAzB,CAAvD;;AAEA,UAAI,CAACgB,IAAI,KAAKR,KAAT,IAAkBQ,IAAI,KAAKP,MAA5B,KAAuC,OAAOS,YAAP,KAAwB,UAAnE,EAA+E;AAC7E,cAAM,IAAID,KAAJ,mDACsCD,IAAI,CAAChB,IAD3C,wCAAN;AAGD;;AAEDS,MAAAA,MAAM,CAACW,cAAP,CAAsB,KAAtB,EAA4BpB,IAA5B,EAAkC;AAChCqB,QAAAA,GADgC,iBAC1B;AACJ,iBAAO,KAAKA,GAAL,CAASrB,IAAT,EAAegB,IAAf,EAAqBE,YAArB,CAAP;AACD,SAH+B;AAIhCI,QAAAA,GAJgC,eAI5BC,KAJ4B,EAIrB;AACT,eAAKD,GAAL,CAAStB,IAAT,EAAegB,IAAf,EAAqBO,KAArB;AACD,SAN+B;AAOhCC,QAAAA,UAAU,EAAE;AAPoB,OAAlC;AASD,KA9BD;AAgCA,WAAO,IAAP;AACD;;;;wBASGxB,I,EAAMgB,I,EAAME,Y,EAAc;AAAA;;AAC5B,UAAMO,aAAa,GAAG1B,gBAAgB,CAACC,IAAD,CAAtC;;AACA,UAAM0B,YAAY,GAAG,sCAAcA,YAAd,CAA2BD,aAA3B,CAArB;;AAEA,UAAIT,IAAI,KAAKT,OAAb,EAAsB;AACpB,YAAI,CAACmB,YAAD,IAAiBR,YAArB,EAAmC;AACjC,gDAAcS,YAAd,CAA2BF,aAA3B,EAA0C,EAA1C;AACD;;AACD,eAAOC,YAAY,IAAIR,YAAvB;AACD;;AAED,UAAMK,KAAK,GAAG,sCAAcK,YAAd,CAA2BH,aAA3B,CAAd;;AAEA,UAAIT,IAAI,KAAKV,MAAb,EAAqB;AACnB,eAAOoB,YAAY,GAAGpB,MAAM,CAACiB,KAAD,CAAT,GAAmBL,YAAtC;AACD;;AAED,UAAIF,IAAI,KAAKR,KAAT,IAAkBQ,IAAI,KAAKP,MAA/B,EAAuC;AACrC,YAAMoB,GAAG,GAAGjC,SAAS,CACnBsB,YAAY,EADO,EAEnBQ,YAAY,GAAGI,IAAI,CAACC,KAAL,CAAWR,KAAX,CAAH,GAAuB,4CAAoBP,IAAI,CAAChB,IAAzB,GAFhB,CAArB;;AAKA,YAAI,CAAC,qCAAaA,IAAb,CAAL,EAAyB;AACvB,+CAAaA,IAAb,IAAqB6B,GAArB;AACD,SAFD,MAEO,IAAIA,GAAG,KAAK,qCAAa7B,IAAb,CAAZ,EAAgC;AAMrCgC,UAAAA,UAAU,CAAC,YAAM;AACf,kCAAA,MAAI,WAAJ,CAAcL,YAAd,CAA2BF,aAA3B,EAA0CK,IAAI,CAACG,SAAL,CAAe,sBAAA,MAAI,UAAJ,CAAajC,IAAb,CAAf,CAA1C;AACD,WAFS,EAEP,CAFO,CAAV;AAGD;;AAED,eAAO,qCAAaA,IAAb,CAAP;AACD;;AAED,aAAO0B,YAAY,GAAGH,KAAH,GAAWL,YAA9B;AACD;;;wBASGlB,I,EAAMgB,I,EAAMO,K,EAAO;AACrB,UAAME,aAAa,GAAG1B,gBAAgB,CAACC,IAAD,CAAtC;;AAEA,UAAIuB,KAAK,CAACW,WAAN,CAAkBlC,IAAlB,KAA2BgB,IAAI,CAAChB,IAApC,EAA0C;AACxC,YAAM6B,GAAG,GAAGrB,KAAK,CAAC2B,OAAN,CAAcZ,KAAd,KAAwBzB,QAAQ,CAACyB,KAAD,CAAhC,GAA0CO,IAAI,CAACG,SAAL,CAAeV,KAAf,CAA1C,GAAkEA,KAA9E;AACA,cAAM,IAAIa,SAAJ,iBACIP,GADJ,gCAC2B7B,IAD3B,yCAC4DgB,IAAI,CAAChB,IADjE,QAAN;AAGD;;AAED,cAAQgB,IAAR;AACE,aAAKT,OAAL;AACE,cAAIgB,KAAJ,EAAW;AACT,kDAAcI,YAAd,CAA2BF,aAA3B,EAA0C,EAA1C;AACD,WAFD,MAEO;AACL,kDAAcY,eAAd,CAA8BZ,aAA9B;AACD;;AACD;;AACF,aAAKjB,KAAL;AACA,aAAKC,MAAL;AACE,+CAAaT,IAAb,IAAqBuB,KAArB;;AACA,gDAAcI,YAAd,CAA2BF,aAA3B,EAA0CK,IAAI,CAACG,SAAL,CAAeV,KAAf,CAA1C;;AACA;;AACF;AACE,gDAAcI,YAAd,CAA2BF,aAA3B,EAA0CF,KAA1C;;AAdJ;AAgBD;;;;;;gBApJkBrB,O,WAQJ,CAACG,MAAD,EAASC,MAAT,EAAiBC,OAAjB,EAA0BC,KAA1B,EAAiCC,MAAjC,C;;SARIP,O","sourcesContent":["import deepmerge from 'deepmerge';\nimport { noCase } from 'no-case';\nimport isObject from '../../../utils/object/isObject';\n\n/**\n * @typedef {StringConstructor|NumberConstructor|BooleanConstructor|ArrayConstructor|ObjectConstructor} OptionType\n * @typedef {{ [name:string]: OptionType | { type: OptionType, default: String|Number|Boolean|(() => Array|Object)} }} OptionsSchema\n */\n\n/**\n * Get the attribute name based on the given option name.\n * @param {String} name The option name.\n */\nfunction getAttributeName(name) {\n  return `data-option-${noCase(name, { delimiter: '-' })}`;\n}\n\n/**\n * Class options to manage options as data attributes on an HTML element.\n */\nexport default class Options {\n  /** @type {HTMLElement} The HTML element holding the options attributes. */\n  #element;\n\n  /** @type {Object} An object to store Array and Object values for reference. */\n  #values = {};\n\n  /** @type {Array} List of allowed types. */\n  static types = [String, Number, Boolean, Array, Object];\n\n  /**\n   * The default values to return for each available type.\n   * @type {Object}\n   */\n  #defaultValues = {\n    String: '',\n    Number: 0,\n    Boolean: false,\n    Array: () => [],\n    Object: () => ({}),\n  };\n\n  /**\n   * Class constructor.\n   *\n   * @param {HTMLElement}   element The HTML element storing the options.\n   * @param {OptionsSchema} schema  A Base class config.\n   */\n  constructor(element, schema) {\n    this.#element = element;\n\n    Object.entries(schema).forEach(([name, config]) => {\n      const isObjectConfig = !Options.types.includes(config);\n      /** @type {OptionType} */\n      // @ts-ignore\n      const type = isObjectConfig ? config.type : config;\n\n      if (!Options.types.includes(type)) {\n        throw new Error(\n          `The \"${name}\" option has an invalid type. The allowed types are: String, Number, Boolean, Array and Object.`\n        );\n      }\n\n      // @ts-ignore\n      const defaultValue = isObjectConfig ? config.default : this.#defaultValues[type.name];\n\n      if ((type === Array || type === Object) && typeof defaultValue !== 'function') {\n        throw new Error(\n          `The default value for options of type \"${type.name}\" must be returned by a function.`\n        );\n      }\n\n      Object.defineProperty(this, name, {\n        get() {\n          return this.get(name, type, defaultValue);\n        },\n        set(value) {\n          this.set(name, type, value);\n        },\n        enumerable: true,\n      });\n    });\n\n    return this;\n  }\n\n  /**\n   * Get an option value.\n   *\n   * @param {String} name The option name.\n   * @param {ArrayConstructor|ObjectConstructor|StringConstructor|NumberConstructor|BooleanConstructor} type The option data's type.\n   * @param {any} defaultValue The default value for this option.\n   */\n  get(name, type, defaultValue) {\n    const attributeName = getAttributeName(name);\n    const hasAttribute = this.#element.hasAttribute(attributeName);\n\n    if (type === Boolean) {\n      if (!hasAttribute && defaultValue) {\n        this.#element.setAttribute(attributeName, '');\n      }\n      return hasAttribute || defaultValue;\n    }\n\n    const value = this.#element.getAttribute(attributeName);\n\n    if (type === Number) {\n      return hasAttribute ? Number(value) : defaultValue;\n    }\n\n    if (type === Array || type === Object) {\n      const val = deepmerge(\n        defaultValue(),\n        hasAttribute ? JSON.parse(value) : this.#defaultValues[type.name]()\n      );\n\n      if (!this.#values[name]) {\n        this.#values[name] = val;\n      } else if (val !== this.#values[name]) {\n        // When getting the value, wait for the next loop to update the data attribute\n        // with the new value. This is a simple trick to avoid using a Proxy to watch\n        // for any deep changes on an array or object. It should not break anything as\n        // the original value is read once from the data attribute and is then read from\n        // the private property `#values`.\n        setTimeout(() => {\n          this.#element.setAttribute(attributeName, JSON.stringify(this.#values[name]));\n        }, 0);\n      }\n\n      return this.#values[name];\n    }\n\n    return hasAttribute ? value : defaultValue;\n  }\n\n  /**\n   * Set an option value.\n   *\n   * @param {String} name The option name.\n   * @param {ArrayConstructor|ObjectConstructor|StringConstructor|NumberConstructor|BooleanConstructor} type The option data's type.\n   * @param {any} value The new value for this option.\n   */\n  set(name, type, value) {\n    const attributeName = getAttributeName(name);\n\n    if (value.constructor.name !== type.name) {\n      const val = Array.isArray(value) || isObject(value) ? JSON.stringify(value) : value;\n      throw new TypeError(\n        `The \"${val}\" value for the \"${name}\" option must be of type \"${type.name}\"`\n      );\n    }\n\n    switch (type) {\n      case Boolean:\n        if (value) {\n          this.#element.setAttribute(attributeName, '');\n        } else {\n          this.#element.removeAttribute(attributeName);\n        }\n        break;\n      case Array:\n      case Object:\n        this.#values[name] = value;\n        this.#element.setAttribute(attributeName, JSON.stringify(value));\n        break;\n      default:\n        this.#element.setAttribute(attributeName, value);\n    }\n  }\n}\n"],"file":"Options.js"}
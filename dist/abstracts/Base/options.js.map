{"version":3,"sources":["../../../src/abstracts/Base/options.js"],"names":["Options","warn","getLegacyOptionsSchema","instance","config","propsToExclude","Object","keys","reduce","schema","propName","includes","value","type","undefined","constructor","types","Array","default","getParentOptionsSchema","prototype","getterConfig","staticConfig","assign","options","getPrototypeOf","updateOptionsWithLegacyValues","element","legacyOptionsValues","dataset","JSON","parse","err","Error","entries","forEach","optionName","optionValue","getOptions","name","String","log","Boolean","debug","$emit"],"mappings":"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","sourcesContent":["import Options from './classes/Options';\nimport { warn } from './utils';\n\n/**\n * @typedef {import('./index').default} Base\n * @typedef {import('./index').BaseOptions} BaseOptions\n * @typedef {import('./classes/Options').OptionsSchema} OptionsSchema\n */\n\n/**\n * Get the legacy options from the `config` properties.\n *\n * @param {Base}   instance The component's instance.\n * @param {Object} config   The component's config.\n * @return {OptionsSchema}\n */\nfunction getLegacyOptionsSchema(instance, config) {\n  // Add legacy options to the schema\n  const propsToExclude = ['name', 'log', 'debug', 'components', 'refs', 'options'];\n  return Object.keys(config).reduce(\n    /**\n     * @param {OptionsSchema} schema\n     * @param {String} propName\n     */\n    (schema, propName) => {\n      if (propsToExclude.includes(propName)) {\n        return schema;\n      }\n\n      const value = config[propName];\n      let type = value === null || value === undefined ? Object : value.constructor;\n\n      // Default to object type as it should work for any values.\n      if (!Options.types.includes(type)) {\n        type = Object;\n      }\n\n      warn(\n        instance,\n        '\\n  Options must be defined in the `config.options` property.',\n        `\\n  Consider moving the \\`config.${propName}\\` option to \\`config.options.${propName}\\`.`\n      );\n\n      if (type === Array || type === Object) {\n        schema[propName] = { type, default: () => value };\n      } else {\n        schema[propName] = { type, default: value };\n      }\n\n      return schema;\n    },\n    {}\n  );\n}\n\n/**\n * Get the inherited options values from the current instance parent classes.\n * @param {Base} instance The component's instance.\n * @return {OptionsSchema}\n */\nfunction getParentOptionsSchema(instance) {\n  /** @type {OptionsSchema} [description] */\n  let schema = {};\n\n  /** @type {Base|false} Merge inherited options. */\n  let prototype = instance;\n\n  while (prototype) {\n    const getterConfig = prototype.config;\n    // @ts-ignore\n    const staticConfig = prototype.constructor.config;\n    if (getterConfig || staticConfig) {\n      schema = Object.assign(\n        (getterConfig || {}).options || {},\n        (staticConfig || {}).options || {},\n        schema\n      );\n      prototype = Object.getPrototypeOf(prototype);\n    } else {\n      prototype = false;\n    }\n  }\n\n  return schema;\n}\n\n/**\n * Update an Options object with the legacy values from the element's `data-options` attribute.\n *\n * @param {Base}        instance The component's instance.\n * @param {HTMLElement} element The component's root element.\n * @param {Options}     options The component's options.\n */\nfunction updateOptionsWithLegacyValues(instance, element, options) {\n  // Update legacy options with value from the `data-options` attribute\n  let legacyOptionsValues = {};\n  if (element.dataset.options) {\n    warn(\n      instance,\n      'The `data-options` attribute usage is deprecated, use multiple `data-option-...` attributes instead.'\n    );\n    try {\n      legacyOptionsValues = JSON.parse(element.dataset.options);\n    } catch (err) {\n      throw new Error('Can not parse the `data-options` attribute. Is it a valid JSON string?');\n    }\n  }\n\n  Object.entries(legacyOptionsValues).forEach(([optionName, optionValue]) => {\n    options[optionName] = optionValue;\n  });\n}\n\n/**\n * Get a component's options.\n *\n * @param  {Base}        instance The component's instance.\n * @param  {HTMLElement} element  The component's root element.\n * @param  {Object}      config   The component's default config.\n * @return {Options & BaseOptions}              The component's merged options.\n */\nexport function getOptions(instance, element, config) {\n  /** @type {OptionsSchema} */\n  const schema = {\n    name: {\n      type: String,\n      default: config.name,\n    },\n    log: {\n      type: Boolean,\n      default: config.log ?? false,\n    },\n    debug: {\n      type: Boolean,\n      default: config.debug ?? false,\n    },\n    ...getParentOptionsSchema(instance),\n    ...getLegacyOptionsSchema(instance, config),\n    ...(config.options || {}),\n  };\n\n  const options = new Options(element, schema);\n\n  updateOptionsWithLegacyValues(instance, element, options);\n\n  instance.$emit('get:options', options);\n\n  return /** @type {Options & BaseOptions} */ (options);\n}\n\nexport default {\n  getOptions,\n};\n"],"file":"options.js"}
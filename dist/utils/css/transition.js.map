{"version":3,"sources":["../../../src/utils/css/transition.js"],"names":["setClassesOrStyles","element","classesOrStyles","method","classes","styles","testTransition","window","getComputedStyle","transitionDuration","start","__isTransitioning__","from","active","next","hasTransition","Promise","resolve","__transitionEndHandler__","addEventListener","to","end","removeEventListener","transition","name"],"mappings":"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","sourcesContent":["/* eslint no-underscore-dangle: [\"error\", { \"allow\": [\"__isTransitioning__\", \"__transitionEndHandler__\"] }] */\nimport nextFrame from '../nextFrame';\nimport * as classes from './classes';\nimport * as styles from './styles';\n\n/**\n * Update either the classes or the styles of an element with the given method.\n *\n * @param {HTMLElement}   element         The element to update.\n * @param {String|Object} classesOrStyles The classes or styles to apply.\n * @param {String}        method          The method to use, one of `add` or `remove`.\n */\nfunction setClassesOrStyles(element, classesOrStyles, method = 'add') {\n  if (typeof classesOrStyles === 'string') {\n    classes[method](element, classesOrStyles, method);\n  } else {\n    styles[method](element, classesOrStyles, method);\n  }\n}\n\n/**\n * Test if the given element has a transition duration.\n *\n * @param  {HTMLElement} element The element to test.\n * @return {Boolean}             The result of the test.\n */\nfunction testTransition(element) {\n  if (typeof window === 'undefined') {\n    return false;\n  }\n\n  const { transitionDuration } = window.getComputedStyle(element);\n  return !!transitionDuration && transitionDuration !== '0s';\n}\n\n/**\n * Apply the from state.\n *\n * @return {Promise}\n */\nasync function start(element, classesOrStyles) {\n  element.__isTransitioning__ = true;\n  setClassesOrStyles(element, classesOrStyles.from);\n  await nextFrame();\n  setClassesOrStyles(element, classesOrStyles.active);\n  await nextFrame();\n}\n\n/**\n * Apply the active state.\n *\n * @return {Promise}\n */\nasync function next(element, classesOrStyles) {\n  const hasTransition = testTransition(element);\n\n  /* eslint-disable-next-line */\n  return new Promise(async resolve => {\n    if (hasTransition) {\n      element.__transitionEndHandler__ = resolve;\n      element.addEventListener('transitionend', element.__transitionEndHandler__, false);\n    }\n    setClassesOrStyles(element, classesOrStyles.from, 'remove');\n    if (!hasTransition) {\n      await nextFrame();\n    }\n    setClassesOrStyles(element, classesOrStyles.to);\n    await nextFrame();\n    if (!hasTransition) {\n      resolve();\n    }\n  });\n}\n\n/**\n * Apply the final state.\n *\n * @return {void}\n */\nfunction end(element, classesOrStyles) {\n  element.removeEventListener('transitionend', element.__transitionEndHandler__, false);\n  setClassesOrStyles(element, classesOrStyles.to, 'remove');\n  setClassesOrStyles(element, classesOrStyles.active, 'remove');\n  delete element.__isTransitioning__;\n  delete element.__transitionEndHandler__;\n}\n\n/**\n * Manage CSS transition with class.\n *\n * This is heavily inspired by the Vue `<transition>` component\n * and the `@barba/css` package, many thanks to them!\n *\n * @param  {HTMLElement}   element The target element.\n * @param  {String|Object} name    The name of the transition or an object with the hooks classesOrStyles.\n * @return {Promise}               A promise resolving at the end of the transition.\n */\nexport default async function transition(element, name) {\n  const classesOrStyles =\n    typeof name === 'string'\n      ? {\n          from: `${name}-from`,\n          active: `${name}-active`,\n          to: `${name}-to`,\n        }\n      : {\n          from: '',\n          active: '',\n          to: '',\n          ...name,\n        };\n\n  // End any previous transition running on the element.\n  if (element.__isTransitioning__) {\n    end(element, classesOrStyles);\n    await nextFrame();\n  }\n\n  await start(element, classesOrStyles);\n  await next(element, classesOrStyles);\n  end(element, classesOrStyles);\n  return Promise.resolve();\n}\n"],"file":"transition.js"}